import{_ as t,c as a,m as l,t as i,V as e,o}from"./chunks/framework.9nulytGH.js";const r="/assets/compiler.gUnojGXw.png",x=JSON.parse('{"title":"模板编译","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"vue/vue3.0/templateCompile.md","filePath":"vue/vue3.0/templateCompile.md"}'),n={name:"vue/vue3.0/templateCompile.md"},u=e('<h1 id="模板编译" tabindex="-1">模板编译 <a class="header-anchor" href="#模板编译" aria-label="Permalink to &quot;模板编译&quot;">​</a></h1><h3 id="模板编译概念" tabindex="-1">模板编译概念 <a class="header-anchor" href="#模板编译概念" aria-label="Permalink to &quot;模板编译概念&quot;">​</a></h3><p>在Vue 3中，模板编译依然是一个重要的步骤，它将模板转换为渲染函数。 Vue 3中的模板编译相对于Vue 2有一些改进和优化，主要集中在性能、大小和功能上。 以下是一些与Vue 3中模板编译相关的重要概念：</p><h4 id="静态提升-static-hoisting" tabindex="-1">静态提升（Static Hoisting） <a class="header-anchor" href="#静态提升-static-hoisting" aria-label="Permalink to &quot;静态提升（Static Hoisting）&quot;">​</a></h4><ul><li>静态提升（Static Hoisting）是 Vue 3 中的一个编译优化技术，旨在减少渲染函数的创建次数，提高渲染性能。</li><li>它的<code>主要思想</code>是将模板中的静态节点（不会随数据变化而变化的节点）提升到渲染函数外部，在组件的首次渲染时只创建一次，之后复用这些静态节点，避免重复创建和销毁。</li></ul><h6 id="优势" tabindex="-1">优势 <a class="header-anchor" href="#优势" aria-label="Permalink to &quot;优势&quot;">​</a></h6><p>静态提升的主要优势包括：</p><ol><li><strong>减少渲染开销：</strong> 静态提升可以避免在每次重新渲染时重新创建静态节点，而是复用之前创建好的节点，从而减少了渲染所需的时间和内存开销。</li><li><strong>提高渲染性能：</strong> 由于静态节点的复用，Vue 能够更高效地处理模板中的静态内容，从而提高了应用的渲染性能。</li><li><strong>改善用户体验：</strong> 渲染性能的提高可以使页面加载更快、渲染更流畅，从而改善了用户的使用体验。</li><li><strong>优化内存占用：</strong> 避免重复创建静态节点可以减少内存的占用，特别是在页面中包含大量静态内容或者大型应用中，这种优化效果更为明显。</li></ol><blockquote><p>总的来说，静态提升能够有效地优化 Vue 应用的性能表现，特别是在处理大型页面或者包含大量静态内容的情况下，其优势更为显著。</p></blockquote><h4 id="编译器标记-compiler-markers-类型标记" tabindex="-1">编译器标记（Compiler Markers）-- 类型标记 <a class="header-anchor" href="#编译器标记-compiler-markers-类型标记" aria-label="Permalink to &quot;编译器标记（Compiler Markers）-- 类型标记&quot;">​</a></h4><ul><li>Vue 3 的编译标记（compile markers）是指在模板编译过程中用来标识和处理模板中特定语法和指令的标记。</li><li>这些标记告诉编译器如何解析和转换模板，最终生成渲染函数。</li></ul><p>在 Vue 3 中，编译标记包括但不限于以下几种：</p>',12),s=l("li",null,"指令：v-if、v-for、v-bind、v-on等",-1),c=l("li",null,"插槽：<slot>、<template v-slot>等",-1),h=l("li",null,"片段：<template>标签",-1),d=l("li",null,"条件块：v-if、v-else-if、v-else等",-1),p=l("li",null,"循环块：v-for",-1),_=l("li",null,"文本：v-text、v-html等",-1),m=l("li",null,"注释：<!-- -->",-1),V=e('<blockquote><p>编译标记的存在使得 Vue 3 能够在编译模板时正确地识别和处理各种语法，生成对应的渲染函数，从而实现模板的动态渲染和响应式更新。</p></blockquote><hr><h4 id="模板ast-abstract-syntax-tree" tabindex="-1">模板AST（Abstract Syntax Tree） <a class="header-anchor" href="#模板ast-abstract-syntax-tree" aria-label="Permalink to &quot;模板AST（Abstract Syntax Tree）&quot;">​</a></h4><ul><li>模板编译过程中，模板会被解析为AST，即抽象语法树。AST是一个树状结构，用于表示模板的结构和内容，编译器会基于AST生成渲染函数。</li></ul><h4 id="渲染函数-render-function" tabindex="-1">渲染函数（Render Function） <a class="header-anchor" href="#渲染函数-render-function" aria-label="Permalink to &quot;渲染函数（Render Function）&quot;">​</a></h4><ul><li>Vue 3中的模板编译会将模板转换为渲染函数，渲染函数是一段JavaScript代码，用于生成VNode树，进而实现页面的渲染。Vue 3的渲染函数相比Vue 2更加优化，生成的代码更加简洁高效。</li></ul><h5 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h5><ul><li>接收上下文参数： <ul><li>渲染函数可以接收上下文对象作为参数，其中包含了组件实例的状态、属性和方法等信息。</li></ul></li><li>返回虚拟DOM： <ul><li>渲染函数通过生成虚拟DOM树来描述组件的UI结构。这个过程可以使用JSX语法或手动调用createElement函数来完成。</li></ul></li><li>更新DOM： <ul><li>当组件的状态或属性发生变化时，Vue会重新执行渲染函数以获取新的虚拟DOM树。</li><li>然后，Vue会使用新旧虚拟DOM树之间的差异来更新实际的DOM元素，从而实现UI的更新。</li></ul></li></ul><h4 id="模板指令转换-directive-transformation" tabindex="-1">模板指令转换（Directive Transformation） <a class="header-anchor" href="#模板指令转换-directive-transformation" aria-label="Permalink to &quot;模板指令转换（Directive Transformation）&quot;">​</a></h4><ul><li>模板中的指令（如v-if、v-for、v-model等）会被<code>编译器</code>转换为相应的渲染函数代码，以实现指令的功能。</li></ul><h5 id="转换过程" tabindex="-1">转换过程 <a class="header-anchor" href="#转换过程" aria-label="Permalink to &quot;转换过程&quot;">​</a></h5><ul><li>解析模板指令： <ul><li>编译器会遍历模板，识别并解析模板中的指令，例如v-if、v-for等。</li></ul></li><li>生成对应的JavaScript代码： <ul><li>一旦识别了模板指令，编译器会根据指令的类型和参数生成相应的JavaScript代码。</li><li>这些代码通常会被包装成函数，用于在运行时执行。</li></ul></li><li>插入到渲染函数中： <ul><li>生成的JavaScript代码会被插入到渲染函数中的适当位置。</li><li>这样，在组件渲染时，这些代码就会被执行，从而实现了模板指令的功能。</li></ul></li></ul><h4 id="静态节点提取-static-node-hoisting" tabindex="-1">静态节点提取（Static Node Hoisting） <a class="header-anchor" href="#静态节点提取-static-node-hoisting" aria-label="Permalink to &quot;静态节点提取（Static Node Hoisting）&quot;">​</a></h4><ul><li>在Vue 3中，静态节点提取是一种优化技术，用于将静态内容从模板中提取出来并在编译时进行处理。</li><li>静态节点指的是在模板中不会改变的部分，例如纯文本、静态HTML元素等。</li></ul><p>静态节点提取的过程包括以下几个步骤：</p><ul><li><strong>静态节点识别：</strong><ul><li>编译器会遍历模板，识别其中的静态节点。这些节点在编译后不会发生变化，因此可以被提取出来。</li></ul></li><li><strong>静态节点标记：</strong><ul><li>一旦识别了静态节点，编译器会给它们添加特殊的标记，以便在后续的编译过程中进行处理。</li></ul></li><li><strong>静态节点提取：</strong><ul><li>在生成渲染函数的过程中，编译器会将标记过的静态节点提取出来，并生成对应的JavaScript代码。</li><li>这些代码会在组件初始化时执行，将静态内容渲染到页面上。</li></ul></li></ul><blockquote><p>静态节点提取的作用在于优化渲染性能。由于静态节点在渲染过程中不会改变，因此可以在编译时提前处理，避免在运行时重复计算和渲染这些节点，从而减少了渲染所需的时间和资源消耗。 总的来说，静态节点提取是Vue 3中的一个重要优化特性，可以帮助提高应用的性能和用户体验。</p></blockquote><blockquote><p>总的来说，Vue 3中的模板编译经过了许多改进和优化，使得编译过程更加高效，并且生成的渲染函数性能更好，同时还能减小打包体积，提高应用的加载速度。</p></blockquote><hr><h3 id="模板编译过程" tabindex="-1">模板编译过程 <a class="header-anchor" href="#模板编译过程" aria-label="Permalink to &quot;模板编译过程&quot;">​</a></h3><p>在Vue 3中，模板编译是将Vue模板转换为渲染函数的过程。下面是模板编译的大致过程：</p><ol><li><strong>解析：</strong> 编译器首先会解析Vue模板，将其转换为抽象语法树（AST）的表示形式。</li><li><strong>优化：</strong> 一旦获得AST，编译器会对其进行优化，例如静态节点提取、静态属性提升等，以提高渲染性能。</li><li><strong>代码生成：</strong> 接下来，编译器将优化后的AST转换为渲染函数的代码。这个过程会根据AST节点生成相应的JavaScript代码，其中包括创建VNode节点、处理指令、事件处理等。</li><li><strong>生成渲染函数：</strong> 最后，编译器会将生成的代码包装在一个渲染函数中，并返回该函数作为组件的<code>render</code>函数。</li></ol><blockquote><p>总的来说，模板编译的过程包括解析模板、优化AST、生成代码和生成渲染函数这几个步骤，最终将模板转换为可执行的渲染函数。</p></blockquote><p><img src="'+r+'" alt="compiler.png"></p><hr><h3 id="编译器对打包体积的影响" tabindex="-1">编译器对打包体积的影响 <a class="header-anchor" href="#编译器对打包体积的影响" aria-label="Permalink to &quot;编译器对打包体积的影响&quot;">​</a></h3><p>Vue 3 模板编译器对打包体积的影响主要体现在以下几个方面：</p><ol><li><strong>增加编译器的体积：</strong> Vue 3 模板编译器是一个独立的模块，需要被打包到最终的应用代码中。因此，引入编译器会增加应用的总体积。</li><li><strong>增加编译后的代码体积：</strong> 编译器会将模板编译成渲染函数，这些渲染函数也会占用一定的空间。特别是对于包含大量模板的应用，编译后的代码体积可能会比较大。</li><li><strong>减少运行时代码的体积：</strong> 使用编译器可以将模板在构建时编译成渲染函数，避免了在运行时解析模板的开销。虽然增加了编译器的体积，但可以减少最终打包的运行时代码体积。</li><li><strong>优化代码体积：</strong> 编译器可以对模板进行静态节点提取等优化，从而减少最终打包的代码量。这些优化可以降低应用的总体积。</li></ol><blockquote><p>因此，Vue 3 模板编译器对打包体积的影响是双重的。引入编译器会增加一定的体积，但通过编译优化可以减少最终运行时代码的体积，提高应用的性能和体验。</p></blockquote><hr><h3 id="概念自查" tabindex="-1">概念自查 <a class="header-anchor" href="#概念自查" aria-label="Permalink to &quot;概念自查&quot;">​</a></h3><p>当然，这里有一些可能的Vue 3模板编译方面的 问题：</p><ol><li>Vue 3中的模板编译过程是什么样的？</li><li>Vue 3中的模板编译和Vue 2有什么区别？</li><li>Vue 3中的静态模板提升是什么？它有什么优势？</li><li>Vue 3中的编译器标记是用来做什么的？</li><li>Vue 3的模板编译器是如何将模板转换为渲染函数的（模板编译过程）？</li><li>Vue 3中的渲染函数是什么？它是如何工作的？</li><li>Vue 3中的模板指令转换是如何实现的？</li><li>Vue 3中的静态节点提取是什么？它有什么用处？</li><li>Vue 3模板编译器如何优化渲染性能？</li><li>Vue 3模板编译器对打包体积有什么影响？</li></ol><p>这些问题可以帮助 你更深入地了解Vue 3中模板编译的原理和优化策略。</p>',34);function b(g,q,f,v,k,S){return o(),a("div",null,[u,l("ul",null,[l("li",null,"插值表达式："+i(),1),s,c,h,d,p,_,l("li",null,"静态内容："+i()+"外的普通文本",1),m]),V])}const P=t(n,[["render",b]]);export{x as __pageData,P as default};
