import{_ as i,c as s,o as a,V as e}from"./chunks/framework.9nulytGH.js";const b=JSON.parse('{"title":"websocket","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"javaScript/websocket.md","filePath":"javaScript/websocket.md"}'),l={name:"javaScript/websocket.md"},t=e(`<h1 id="websocket" tabindex="-1">websocket <a class="header-anchor" href="#websocket" aria-label="Permalink to &quot;websocket&quot;">​</a></h1><blockquote><p>WebSocket是一种在<code>单个TCP连接</code>上进行<code>全双工通信的协议</code>，它允许在浏览器和服务器之间进行双向通信，从而实现实时的数据传输。与HTTP相比，WebSocket具有以下特点：</p></blockquote><h3 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ol><li>全双工通信： WebSocket允许客户端和服务器之间进行双向通信，即客户端可以向服务器发送消息，服务器也可以向客户端发送消息，而不受请求-响应的限制。</li><li>低延迟： 由于WebSocket在建立连接后保持长时间的连接状态，因此可以实现低延迟的数据传输，适用于实时性要求较高的应用场景，如在线游戏、即时通讯等。</li><li>节省带宽： WebSocket协议采用了轻量级的数据帧格式，相比HTTP协议可以减少通信时的额外开销，从而节省带宽。</li><li>跨域支持： 与传统的AJAX请求不同，WebSocket协议支持跨域通信，可以在浏览器中与不同域的服务器进行通信。</li><li>实时性： 由于WebSocket能够保持长时间的连接状态，因此可以实现实时的数据传输，无需频繁地发起请求，适用于需要及时更新数据的应用场景。</li></ol><h3 id="连接建立过程" tabindex="-1">连接建立过程 <a class="header-anchor" href="#连接建立过程" aria-label="Permalink to &quot;连接建立过程&quot;">​</a></h3><p>WebSocket建立连接的过程如下：</p><ol><li>客户端发送握手请求： 客户端向服务器发送WebSocket握手请求，这个请求类似于HTTP的协议升级请求，但是在头部中包含了<code>Upgrade: websocket</code> 和<code>Connection: Upgrade</code>字段，以及一个随机生成的<code>Sec-WebSocket-Key</code>字段用于安全验证。</li><li>服务器响应握手请求： 服务器收到握手请求后，会进行验证，如果验证通过，就向客户端返回握手确认响应。这个响应包含了与客户端发送的<code>Sec-WebSocket-Key</code> 字段相关的安全验证信息，以及<code>Upgrade: websocket</code>和<code>Connection: Upgrade</code>字段。同时，服务器还会指定一些WebSocket连接的协议选项，如子协议、扩展等。</li><li>连接建立： 客户端收到服务器的握手响应后，会进行验证。如果一切正常，客户端会发送一个确认响应给服务器。此时，WebSocket连接就建立成功了，客户端和服务器就可以开始进行双向通信。</li><li>通信交互： 连接建立后，客户端和服务器就可以通过该连接发送和接收数据了。数据可以以文本或二进制的形式进行传输。</li></ol><p>WebSocket建立连接的过程类似于握手，一旦连接建立成功，客户端和服务器之间就可以进行实时的双向通信。</p><h3 id="通信过程-如何使用websocket" tabindex="-1">通信过程（如何使用websocket） <a class="header-anchor" href="#通信过程-如何使用websocket" aria-label="Permalink to &quot;通信过程（如何使用websocket）&quot;">​</a></h3><ol><li>建立连接： 客户端向服务器发起WebSocket连接请求，请求中包含一些必要的头部信息，如Upgrade、Connection和Sec-WebSocket-Key等。服务器收到请求后，验证信息的合法性，并返回一个带有状态码101的握手响应，表示连接成功建立。</li><li>双向数据传输： 通过监听websocket上的事件进行数据传输。&lt;br&gt; 一旦连接建立成功，客户端和服务器之间就可以通过该连接进行双向数据传输。双方可以随时发送<code>文本或二进制数据</code>，并且不需要等待对方的响应。</li><li>心跳保持连接： 为了保持连接的稳定性，客户端和服务器通常会定时发送心跳消息，以确保连接不会因为长时间没有数据交互而断开。</li><li>关闭连接： 当客户端或服务器需要关闭连接时，可以发送特定的消息来关闭连接。一旦收到关闭连接的消息，对方就会执行相应的关闭操作，并且不再接受新的消息。</li></ol><p>WebSocket的通信过程简单而高效，适用于需要实时双向通信的场景，如在线聊天、实时数据传输等。</p><h3 id="跨域处理" tabindex="-1">跨域处理 <a class="header-anchor" href="#跨域处理" aria-label="Permalink to &quot;跨域处理&quot;">​</a></h3><ul><li>WebSocket协议在设计时考虑了安全性和跨域请求的问题。</li><li>一般情况下，WebSocket连接不受同源策略的限制，因此可以跨域访问。</li></ul><p>在实际应用中，需要注意以下几点：</p><ol><li>服务器配置： 服务器需要支持WebSocket协议，并且需要正确处理跨域请求。一般来说，WebSocket服务器会在响应中包含特定的头部信息（如<code>Access-Control-Allow-Origin</code> ）来允许跨域请求。</li><li>浏览器支持： 浏览器需要支持WebSocket协议，并且需要正确处理跨域请求。大多数现代浏览器都支持WebSocket，并且会遵循同源策略的规则。</li><li>安全性考虑： 跨域请求可能会引发安全问题，因此在设计WebSocket应用时需要考虑安全性，避免被恶意利用。</li></ol><p>总的来说，WebSocket在处理跨域请求时比传统的HTTP请求更加灵活，但仍需要注意安全性和合理性。</p><h3 id="处理异常和错误" tabindex="-1">处理异常和错误 <a class="header-anchor" href="#处理异常和错误" aria-label="Permalink to &quot;处理异常和错误&quot;">​</a></h3><p>在 WebSocket 通信中，可以通过捕获异常和监听事件来处理异常和错误。以下是一些常见的处理方式：</p><ol><li><p>捕获异常：使用 try...catch 语句捕获异常，并在捕获到异常时进行相应的处理。例如，可以在捕获到异常时输出错误信息或重新连接。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // WebSocket 相关操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (error) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;WebSocket 发生异常：&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, error);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 重新连接等操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>监听事件：WebSocket 对象提供了一些事件，可以监听这些事件来处理异常和错误。常见的事件包括 error 事件和 close 事件。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onerror</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;WebSocket 发生错误：&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 重新连接等操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onclose</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;WebSocket 连接关闭：&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 重新连接等操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></li><li><p>重连机制：在发生异常或连接关闭时，可以实现一个重连机制，尝试重新建立连接。可以在捕获异常、监听 close 事件或定时器中实现重连逻辑。</p></li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> socket </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WebSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ws://example.com&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  socket </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WebSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ws://example.com&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 监听事件、发送数据等操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onerror</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;WebSocket 发生错误，尝试重连：&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onclose</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;WebSocket 连接关闭，尝试重连：&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>以上是一些基本的处理方式，具体的处理方式可以根据实际情况和需求进行调整和扩展。</p><h3 id="处理假死" tabindex="-1">处理<code>假死</code> <a class="header-anchor" href="#处理假死" aria-label="Permalink to &quot;处理\`假死\`&quot;">​</a></h3><ul><li>WebSocket 的假死问题通常是指在某些网络环境下，WebSocket 连接出现异常或中断，但客户端并未触发 onClose 事件，而是处于一种“假死”的状态，无法重新连接或重启连接。</li></ul><p>造成 WebSocket 假死的可能原因包括：</p><ol><li>网络中断或不稳定：当客户端与服务器之间的网络连接出现问题时，可能导致 WebSocket 连接异常。这可能是由于网络延迟、丢包、DNS 解析问题等原因造成的。</li><li>服务器端异常：服务器端的异常或错误可能会导致 WebSocket 连接中断或失效。这可能包括服务器的崩溃、过载、异常退出等情况。</li><li>防火墙或代理限制：一些网络环境下可能存在防火墙、代理服务器或负载均衡器等设备，它们可能会对 WebSocket 连接进行限制或干扰，导致连接异常或中断。</li></ol><p>针对 WebSocket 的假死问题，可以考虑以下解决方法：</p><ol><li>实现心跳检测机制：客户端和服务器可以约定一个时间间隔，在这个时间间隔内相互发送心跳消息，以确保连接的活跃性。如果一段时间内没有收到心跳消息，可以认为连接出现异常，并尝试重新连接或关闭连接。</li><li>实现重连机制：在检测到连接异常或中断时，客户端可以尝试重新建立连接。可以设置重连的间隔时间和重连次数，以提高连接成功的几率。</li><li>优化网络环境：尽量避免在不稳定的网络环境下使用 WebSocket，如果可能的话，可以优化网络配置或切换到更稳定的网络环境。</li></ol><p>通过以上方法，可以有效地解决 WebSocket 假死的问题，提高连接的稳定性和可靠性。</p><h3 id="通信安全" tabindex="-1">通信安全 <a class="header-anchor" href="#通信安全" aria-label="Permalink to &quot;通信安全&quot;">​</a></h3><p>要确保 WebSocket 通信安全，可以采取以下措施：</p><ol><li>使用安全的连接：使用安全的 WebSocket 连接（wss://）代替普通的连接（ws://），以确保数据在传输过程中进行加密。</li><li>验证消息来源：在服务器端对客户端发送的消息进行验证，确保消息来源可信。可以使用 token 或其他身份验证机制来验证客户端的身份。</li><li>限制消息大小：限制客户端发送的消息大小，防止恶意用户发送大量数据造成服务器资源浪费或拒绝服务攻击。</li><li>限制连接数：限制每个客户端的连接数，防止一个客户端建立大量连接导致服务器资源耗尽。</li><li>定期检查连接状态：定期检查客户端与服务器端的连接状态，及时发现异常连接并进行处理。</li><li>使用 SSL/TLS：在使用 WebSocket 时，建议在服务器端配置 SSL/TLS 证书，以确保通信过程中数据的加密和安全传输。</li></ol><p>通过以上措施，可以有效地提高 WebSocket 通信的安全性，保护通信双方的数据安全。</p><h3 id="wss-vs-https" tabindex="-1">wss vs. https <a class="header-anchor" href="#wss-vs-https" aria-label="Permalink to &quot;wss vs. https&quot;">​</a></h3><p>WSS（WebSocket Secure）和 HTTPS（HTTP Secure）都是通过 TLS/SSL 加密传输数据的安全通信协议，但它们用于不同的通信方式：</p><ol><li><p>HTTPS:</p><ul><li>HTTPS 是 HTTP 协议的安全版本，用于在客户端和服务器之间进行加密的 HTTP 通信。</li><li>主要用于浏览器和 Web 服务器之间的安全通信，用于传输网页、图像、脚本等资源。</li><li>HTTPS 使用在 TCP/IP 层之上的安全层进行数据加密，保护传输的内容不被窃听或篡改。</li></ul></li><li><p>WSS:</p><ul><li>WSS 是 WebSocket 协议的安全版本，用于在客户端和服务器之间进行加密的双向实时通信。</li><li>主要用于实现实时双向通信，例如在线聊天、游戏应用等。</li><li>WSS 同样使用 TLS/SSL 加密数据传输，但它建立在 HTTP 或 HTTPS 协议之上，并提供持久的连接，允许客户端和服务器之间进行双向通信。</li></ul></li></ol><p>总的来说，HTTPS 用于加密传输静态资源和一次性请求的数据，而 WSS 则用于建立持久的双向通信通道，适用于需要实时交互的应用场景。</p><h3 id="与http-区别" tabindex="-1">与http 区别 <a class="header-anchor" href="#与http-区别" aria-label="Permalink to &quot;与http 区别&quot;">​</a></h3><blockquote><p>与传统的HTTP请求-响应模式不同，WebSocket允许服务器在<code>没有接收到客户端请求</code>的情况下向客户端<code>发送数据</code>。</p></blockquote><p>主要的区别包括：</p><ol><li>通信方式： <ul><li>HTTP是一种无状态协议，它通过客户端向服务器发送请求，然后服务器响应该请求。</li><li>WebSocket是一种全双工协议，允许客户端和服务器之间同时发送和接收数据，而不需要等待请求和响应。</li></ul></li><li>连接方式： <ul><li>HTTP使用短连接，在请求-响应周期结束后，连接会立即关闭。</li><li>WebSocket使用长连接，在建立连接后，可以保持连接状态并持续发送和接收数据。</li></ul></li><li>数据格式： <ul><li>HTTP使用明文文本或二进制格式发送数据。</li><li>WebSocket可以发送文本或二进制数据，且没有HTTP的头部信息。</li></ul></li><li>性能开销： <ul><li>由于HTTP是基于文本的协议，并且需要在每次通信中发送大量的头部信息，因此它的性能开销相对较高。</li><li>WebSocket使用更少的数据包，减少了通信开销，并且具有更高的性能。</li></ul></li></ol><h3 id="与http长连接-区别" tabindex="-1">与http长连接 区别 <a class="header-anchor" href="#与http长连接-区别" aria-label="Permalink to &quot;与http长连接 区别&quot;">​</a></h3><p>WebSocket 和 HTTP 长连接都可以用于实现持久连接，但它们在工作原理和应用场景上有一些区别：</p><ol><li>工作原理： <ul><li>WebSocket：WebSocket 是一种独立的协议，与 HTTP 协议不同。WebSocket 连接建立后，客户端和服务器之间可以进行全双工通信，双方可以同时发送和接收数据，而不需要每次通信都发起新的请求。</li><li>HTTP 长连接：HTTP 长连接是在 HTTP 协议的基础上实现的一种机制。它通过在请求头中包含 <code>Connection: keep-alive</code> 字段来告知服务器保持连接，从而避免了每次请求都建立新的连接，但仍然需要客户端发起请求才能获取服务器的响应。</li></ul></li><li>应用场景： <ul><li>WebSocket：适用于需要实时双向通信的场景，如即时聊天、实时数据推送等。由于 WebSocket 可以在客户端和服务器之间建立持久连接，因此可以实时地将数据推送给客户端，而无需客户端发起请求。</li><li>HTTP 长连接：适用于需要保持连接但不需要实时双向通信的场景。HTTP 长连接可以减少建立连接的开销，但由于仍然需要客户端发起请求才能获取服务器的响应，因此不能实时地将数据推送给客户端。 总的来说，WebSocket 更适用于需要实时双向通信的场景，而 HTTP 长连接则更适用于需要保持连接但不需要实时双向通信的场景。</li></ul></li></ol><h3 id="概念自查" tabindex="-1">概念自查 <a class="header-anchor" href="#概念自查" aria-label="Permalink to &quot;概念自查&quot;">​</a></h3><ol><li>WebSocket是什么？它与HTTP有什么区别？</li><li>WebSocket如何建立连接？</li><li>WebSocket的通信过程是怎样的？</li><li>WebSocket如何处理跨域请求？</li><li>WebSocket和HTTP长连接有什么区别？</li><li>在WebSocket通信中，如何处理异常和错误？</li><li>WebSocket的数据传输格式是什么？</li><li>WebSocket如何实现实时通信？</li><li>WebSocket连接的保持时间有限吗？如果需要保持长时间连接，应该如何处理？</li><li>在使用WebSocket时，如何确保通信安全？</li></ol>`,45),n=[t];function k(h,p,o,c,r,d){return a(),s("div",null,n)}const g=i(l,[["render",k]]);export{b as __pageData,g as default};
