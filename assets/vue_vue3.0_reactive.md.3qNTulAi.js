import{_ as s,c as i,o as a,V as n}from"./chunks/framework.j2uNBPO8.js";const c=JSON.parse('{"title":"响应式数据","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"vue/vue3.0/reactive.md","filePath":"vue/vue3.0/reactive.md"}'),l={name:"vue/vue3.0/reactive.md"},t=n(`<h1 id="响应式数据" tabindex="-1">响应式数据 <a class="header-anchor" href="#响应式数据" aria-label="Permalink to &quot;响应式数据&quot;">​</a></h1><h3 id="实现原理" tabindex="-1">实现原理 <a class="header-anchor" href="#实现原理" aria-label="Permalink to &quot;实现原理&quot;">​</a></h3><ul><li>Vue 3 中响应式数据的实现原理主要基于 ES6 的 Proxy 对象和 Reflect 对象。</li><li>当你创建一个响应式对象时，Vue 3 会使用 Proxy 包装它，然后监听对象的属性访问、赋值和删除等操作。</li><li>当对响应式对象进行操作时，Proxy 会拦截这些操作，并触发相应的更新。这样就实现了数据的响应式更新。</li></ul><h4 id="与vue2-x差异及改进" tabindex="-1">与vue2.x差异及改进 <a class="header-anchor" href="#与vue2-x差异及改进" aria-label="Permalink to &quot;与vue2.x差异及改进&quot;">​</a></h4><p>Vue 3 中相对于 Vue 2.x 在响应式数据方面的改进包括：</p><ol><li><strong>Proxy 替代 Object.defineProperty：</strong> Vue 3 使用 Proxy 对象来代替 Vue 2.x 中的 Object.defineProperty，使得响应式系统更加灵活和高效。</li><li><strong>性能提升：</strong> 使用 Proxy 对象可以在访问属性时拦截，而不是像 Object.defineProperty 一样在属性被读取或设置时才进行拦截，这带来了性能上的提升。</li><li><strong>更好的 TypeScript 支持：</strong> Vue 3 对 TypeScript 的支持更加友好，包括更准确的类型推断和更好的类型提示。</li><li><strong>Composition API：</strong> Vue 3 引入了 Composition API，使得组件内部的逻辑更加清晰，可以更好地组织和复用响应式逻辑。</li><li><strong>更好的 Tree-shaking 支持：</strong> Vue 3 的模块系统和编译器优化使得 Tree-shaking 更加容易和有效，减少了打包体积。</li><li><strong>更灵活的响应式数据处理：</strong> Vue 3 的响应式系统更加灵活，可以更方便地处理异步数据和副作用。</li><li><strong>更少的运行时代码：</strong> Vue 3 中去除了 Vue 2.x 中一些不常用的特性和代码，使得运行时更加轻量。</li><li><strong>其他优化：</strong> Vue 3 还对响应式系统进行了其他一些优化，包括更好地支持嵌套对象和数组的响应式等。</li></ol><hr><h4 id="关于数组类型的注意" tabindex="-1">关于数组类型的注意 <a class="header-anchor" href="#关于数组类型的注意" aria-label="Permalink to &quot;关于数组类型的注意&quot;">​</a></h4><ul><li>对于直接通过索引或 length 属性修改数组的情况，Vue 3 目前无法实现完全的响应式，开发者需要通过特定的方法（例如 Vue 提供的 $set 方法）来通知 Vue 执行更新</li></ul><hr><h4 id="proxy-vs-object-defineproperty" tabindex="-1">Proxy vs Object.defineProperty <a class="header-anchor" href="#proxy-vs-object-defineproperty" aria-label="Permalink to &quot;Proxy vs Object.defineProperty&quot;">​</a></h4><p>Proxy 和 Object.defineProperty 都是 JavaScript 中用于实现数据劫持的方式，但它们有一些区别：</p><ol><li><strong>语法和用法</strong>： <ul><li>Proxy 是 ES6 中新增的语法，通过创建一个代理对象来拦截对<code>目标对象</code>的操作。 <ul><li>它提供了一组可拦截的操作方法（例如 get、set、deleteProperty 等），可以更灵活地实现对对象的代理。</li></ul></li><li>Object.defineProperty 是 ES5 中引入的方法，它通过定义对象的属性来实现数据劫持。 <ul><li>它<code>只能劫持对象的属性</code>，而且只能定义数据属性（即value、writable、enumerable 和 configurable），无法劫持整个对象。</li></ul></li></ul></li><li><strong>性能和功能</strong>： <ul><li>Proxy 的功能更为强大，可以拦截对象的更多操作，包括属性的读取、写入、删除、枚举等，而且可以直接代理整个对象，实现<code>全方位的数据劫持</code> 。但是，由于 Proxy 是一个新的特性，可能在某些老版本浏览器上不被支持，而且性能相对较低。</li><li>Object.defineProperty 的功能相对较弱，只能<code>劫持对象的属性</code> 读取和写入操作，而且无法直接代理整个对象。但是，它是一个较为成熟和稳定的特性，在大部分浏览器中都能得到支持，并且性能较为稳定。</li></ul></li></ol><blockquote><p>综上所述，Proxy 在功能和灵活性上更胜一筹，而 Object.defineProperty 则更稳定，适用于需要在老版本浏览器上使用的场景。在现代浏览器环境下，推荐使用 Proxy 来实现数据劫持。</p></blockquote><hr><h3 id="ref-vs-reactive" tabindex="-1">ref vs reactive <a class="header-anchor" href="#ref-vs-reactive" aria-label="Permalink to &quot;ref vs reactive&quot;">​</a></h3><p>在 Vue 3 中，<code>ref()</code> 和 <code>reactive()</code> 都是用来创建响应式数据的函数，但它们有一些区别：</p><ol><li><p><strong>ref()</strong>：</p><ul><li><code>ref()</code> 用来创建一个包装对象，将基本类型数据或对象包装成响应式对象。</li><li>当使用 <code>ref()</code> 包装基本类型数据时，它会返回一个包含 <code>.value</code> 属性的对象，该属性用来访问和修改包装的基本类型数据。</li><li>当使用 <code>ref()</code> 包装对象时，它会返回一个包含 <code>.value</code> 属性的对象，该属性指向原始对象，可以直接修改对象的属性。</li></ul><p>示例：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个包装基本类型数据的 ref 对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count.value); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 访问包装的数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count.value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 修改包装的数据</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {foo: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bar&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> objRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个包装对象的 ref 对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(objRef.value.foo); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 访问包装的对象属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">objRef.value.foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;baz&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 修改包装的对象属性</span></span></code></pre></div></li><li><p><strong>reactive()</strong>：</p><ul><li><code>reactive()</code> 用来创建一个响应式代理对象，可以包装普通对象并使其具有响应性。</li><li>返回的对象是一个 Proxy，可以监听对象的属性访问和修改，并触发相应的更新。</li><li><code>reactive()</code> 创建的响应式对象不需要通过 <code>.value</code> 来访问或修改内部数据。</li></ul><p>示例：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个包装对象的 ref 对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state.count); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 访问包装的数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state.count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 修改包装的数据</span></span></code></pre></div></li></ol><blockquote><p>总的来说，<code>ref()</code> 主要用于包装<code>基本类型数据和对象</code>，需要通过 <code>.value</code> 来访问和修改数据；而 <code>reactive()</code> 主要用于包装<code>普通对象</code>，可以直接访问和修改对象的属性。</p></blockquote><h3 id="响应式丢失" tabindex="-1">响应式丢失 <a class="header-anchor" href="#响应式丢失" aria-label="Permalink to &quot;响应式丢失&quot;">​</a></h3><p>在Vue 3中，响应式丢失通常是由于以下原因之一引起的：</p><ol><li><strong>原始值赋值：</strong> 如果将一个响应式对象的属性直接赋值为一个非响应式的值（如普通对象、数组等），那么该属性就会失去响应性。<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state.count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 该属性失去了响应性</span></span></code></pre></div></li><li><strong>数组索引赋值：</strong> 当直接通过索引修改响应式数组时，由于Vue无法检测到这种修改，数组的响应性可能会丢失。<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 该操作可能导致响应性丢失</span></span></code></pre></div></li><li><strong>新增属性：</strong> 当给一个响应式对象添加新属性时，Vue不会自动使其成为响应式属性。<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state.newProp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;new&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新属性不是响应式的</span></span></code></pre></div></li><li><strong>对象方法调用：</strong> 当调用一个响应式对象的方法时，该方法可能会返回一个非响应式的值，导致响应性丢失。<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newObj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">someMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// newObj可能不是响应式的</span></span></code></pre></div></li></ol><p>要解决响应式丢失问题，可以通过以下方法：</p><ul><li>使用 <code>toRefs()</code> 或 <code>toRef()</code> 将响应式对象的属性转换为独立的响应式引用。</li><li>使用 <code>readonly()</code> 将响应式对象或数组转换为只读的响应式对象或数组，防止意外修改。</li><li>在修改数组时，使用 Vue 提供的数组操作方法，如 <code>push()</code>、<code>pop()</code>、<code>splice()</code> 等，以保持响应性。</li><li>使用 <code>reactive()</code> 包装新属性，以使其成为响应式属性。</li></ul><p>请注意，虽然Vue 3的响应式系统更加灵活和强大，但仍然需要谨慎处理可能导致响应式丢失的情况。</p><h3 id="组件间的数据-响应式-共享" tabindex="-1">组件间的数据（响应式）共享 <a class="header-anchor" href="#组件间的数据-响应式-共享" aria-label="Permalink to &quot;组件间的数据（响应式）共享&quot;">​</a></h3><p>在Vue 3中，您可以使用以下方法在组件之间共享响应式数据：</p><ol><li><p><strong>通过 props 传递数据：</strong> 可以通过在父组件中使用 props 将数据传递给子组件。这种方式适用于将父组件的数据传递给子组件，实现数据共享。</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- ParentComponent.vue --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">ChildComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ref } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ChildComponent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./ChildComponent.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  components: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ChildComponent,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> message</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello from parent&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { message };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- ChildComponent.vue --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{ message }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  props: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    message: String,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><p><strong>通过 provide 和 inject：</strong> 可以使用 provide 和 inject 来在组件树中提供和注入响应式数据。provide 可以在父组件中提供数据，而 inject 可以在子组件中注入数据。</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- ParentComponent.vue --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">ChildComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { provide, ref } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ChildComponent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./ChildComponent.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  components: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ChildComponent,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> message</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello from parent&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    provide</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, message);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- ChildComponent.vue --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{ injectedMessage }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { inject } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> injectedMessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { injectedMessage };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><p><strong>通过 Vuex 状态管理：</strong> 如果需要在多个组件之间共享全局状态，则可以使用 Vuex。Vuex 提供了一个集中式的存储仓库，可以在任何组件中访问和修改共享的状态。</p></li></ol><blockquote><p>以上是在Vue 3中实现组件之间共享响应式数据的一些方法，您可以根据具体情况选择适合的方式。</p></blockquote><hr><h3 id="数据循环引用" tabindex="-1">数据循环引用 <a class="header-anchor" href="#数据循环引用" aria-label="Permalink to &quot;数据循环引用&quot;">​</a></h3><blockquote><p>在 Vue 3 中，处理数据循环引用可能会导致一些问题，特别是在使用响应式数据时。由于 Vue 3 使用 Proxy 来实现响应式系统，循环引用可能会导致 Proxy 陷入死循环，从而影响应用的性能和稳定性。</p></blockquote><p>如果在 Vue 3 中遇到循环引用的情况，可以考虑采用以下几种方式来解决：</p><ol><li><strong>避免循环引用：</strong> 尽量设计避免对象之间产生循环引用的数据结构。这可以通过合理的数据设计和业务逻辑来实现。</li><li><strong>手动检测和处理循环引用：</strong> 可以在代码中手动检测数据中的循环引用，并进行相应的处理，例如在遍历对象时检查是否存在循环引用，或者使用适当的算法来处理循环引用的情况。</li><li><strong>使用工具库：</strong> 可以考虑使用一些工具库来处理循环引用的情况。例如，可以使用 <code>json-cycle</code> 库来序列化和反序列化包含循环引用的对象，或者使用 <code>circular-json</code> 库来处理 JSON 对象中的循环引用。</li><li><strong>使用深拷贝：</strong> 在某些情况下，可以通过深拷贝对象来避免循环引用问题。Vue 3 中可以使用 <code>reactive()</code> 或 <code>toRefs()</code> 函数来创建响应式数据，并使用 <code>JSON.parse(JSON.stringify())</code> 等方法来进行深拷贝。</li></ol><blockquote><p>无论采取哪种方式，都需要根据具体情况选择合适的方法来处理循环引用，以确保应用的性能和稳定性。</p></blockquote><h3 id="概念自查" tabindex="-1">概念自查 <a class="header-anchor" href="#概念自查" aria-label="Permalink to &quot;概念自查&quot;">​</a></h3><ol><li>Vue 3 中响应式数据的实现原理是什么？</li><li>与 Vue 2.x 相比，Vue 3 中的响应式数据有哪些改进？</li><li>什么是 Proxy 对象？它在 Vue 3 的响应式数据系统中的作用是什么？</li><li>Vue 3 响应式数据系统中的数据变化是如何被检测和触发更新的？</li><li>Vue 3 响应式数据系统如何处理数组的变化？</li><li>什么是 ref() 和 reactive()？它们有什么区别？</li><li>Vue 3 中的响应式数据如何在组件之间共享？</li><li>Vue 3 中如何监听响应式数据的变化？</li></ol>`,37),e=[t];function h(p,k,r,E,d,o){return a(),i("div",null,e)}const y=s(l,[["render",h]]);export{c as __pageData,y as default};
