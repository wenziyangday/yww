import{_ as i,c as l,o as e,V as a}from"./chunks/framework.j2uNBPO8.js";const n=JSON.parse('{"title":"虚拟DOM","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"vue/vue2.0/vdom.md","filePath":"vue/vue2.0/vdom.md"}'),o={name:"vue/vue2.0/vdom.md"},t=a('<h1 id="虚拟dom" tabindex="-1">虚拟DOM <a class="header-anchor" href="#虚拟dom" aria-label="Permalink to &quot;虚拟DOM&quot;">​</a></h1><blockquote><p>虚拟DOM（Virtual DOM）是一种用JavaScript<code>对象表示真实DOM结构</code>的技术。在Vue.js、React等现代前端框架中广泛应用。 虚拟DOM的主要思想是在<code>内存中</code>维护一个以JavaScript对象表示的DOM树，称为虚拟DOM树。 当状态发生变化时，框架会先对虚拟DOM进行修改，然后通过一种称为“协调算法”的机制，将修改后的虚拟DOM与之前的虚拟DOM进行比较，找出两者之间的差异。 最后，框架将差异应用于真实的DOM上，更新用户界面。</p></blockquote><p>虚拟DOM的优点包括：</p><ol><li>性能优化：通过比较虚拟DOM树的差异，可以最小化DOM操作，提高页面渲染性能。</li><li>跨平台支持：虚拟DOM是基于JavaScript对象的抽象，可以在不同平台上运行，如浏览器、服务器等。</li><li>简化复杂度：虚拟DOM使得开发者无需手动操作DOM，只需要关注数据的变化和页面的逻辑，简化了开发流程。</li><li>提升用户体验：通过虚拟DOM，可以实现高效的页面更新，提升用户界面的响应速度和流畅度。</li></ol><p>虚拟DOM的缺点包括：</p><ol><li>内存消耗：虚拟DOM需要在内存中维护一份DOM的副本，可能会占用较多的内存空间。</li><li>学习成本：使用虚拟DOM需要掌握相关的概念和技术，对于一些初学者来说可能会增加学习成本。</li><li>性能开销：虽然虚拟DOM可以提高页面渲染性能，但在某些情况下，比如对大型列表进行频繁的增删操作时，虚拟DOM的性能开销可能会比直接操作DOM更大。</li></ol><blockquote><p>总的来说，虚拟DOM是一种有效的前端性能优化技术，但在实际应用中需要权衡其优缺点，根据具体场景进行选择。</p></blockquote><ul><li></li></ul><h3 id="虚拟dom工作原理" tabindex="-1">虚拟dom工作原理 <a class="header-anchor" href="#虚拟dom工作原理" aria-label="Permalink to &quot;虚拟dom工作原理&quot;">​</a></h3><blockquote><p>在Vue 2.0中，虚拟DOM的工作原理与其他现代JavaScript框架（如React）类似。 虚拟DOM是一个内存中的JavaScript对象，它对应着真实DOM的层次结构，但是它具备了更高的性能，因为它不直接操作真实的DOM，而是在内存中进行操作。</p></blockquote><p>Vue.js 2.0 中的虚拟 DOM 工作原理如下：</p><ol><li>模板编译： Vue 组件中的模板会被编译为渲染函数。渲染函数可以理解为 JavaScript 函数，用于生成虚拟 DOM。</li><li>生成虚拟 DOM： 渲染函数执行后会生成虚拟 DOM（Virtual DOM）树。这棵树结构对应着页面的结构，但是是在内存中的 JavaScript 对象，不是真实的 DOM 元素。</li><li>挂载虚拟 DOM： Vue 会将生成的虚拟 DOM 挂载到真实的 DOM 元素上，此时页面会根据虚拟 DOM 的结构进行渲染。</li><li>侦听数据变化： Vue 会监听数据的变化，当数据发生变化时，会重新执行渲染函数生成新的虚拟 DOM。</li><li>对比差异： Vue 会将新生成的虚拟 DOM 和旧的虚拟 DOM 进行对比，找出两者之间的差异。</li><li>更新 DOM： Vue 会将差异转化为最小的 DOM 操作，然后更新到页面上。这样做的好处是尽量减少真实 DOM 的操作，提高页面的渲染效率。</li></ol><blockquote><p>Vue 2.0 中的虚拟 DOM 通过这样的机制实现了数据驱动视图的更新。相比直接操作真实 DOM，通过虚拟 DOM 进行 DOM 操作能够提高性能，并且更易于维护和理解。</p></blockquote><h3 id="真实dom" tabindex="-1">真实dom <a class="header-anchor" href="#真实dom" aria-label="Permalink to &quot;真实dom&quot;">​</a></h3><blockquote><p>真实DOM（Document Object Model）是指浏览器中<code>实际存在</code>的、由浏览器解析HTML文档后生成的DOM树。 它由多个节点组成，每个节点代表HTML文档中的一个元素，例如&lt;div&gt;、&lt;p&gt;等，以及它们的属性和文本内容。</p></blockquote><ol><li>真实DOM与虚拟DOM相比，是指直接操作浏览器中的实际DOM元素。</li><li>真实DOM的操作会直接触发浏览器的渲染引擎进行页面的重绘和重排，因此在大量的DOM操作时会产生性能问题，因为DOM操作是比较昂贵的。</li></ol><ul><li></li></ul><p>虚拟DOM相比于真实DOM具有以下优势：</p><ol><li>性能优势： 虚拟DOM可以在内存中进行高效的操作，而不涉及直接操作页面的DOM节点，因此可以减少页面重绘和重排的次数，提高页面的渲染性能。</li><li>跨平台兼容性： 虚拟DOM是由JavaScript对象构成的，因此可以轻松地在不同的平台上进行渲染，例如浏览器、服务器端、移动端等，而真实DOM则依赖于浏览器的API，不具备跨平台兼容性。</li><li>便于批量更新： 虚拟DOM可以进行批量操作和异步更新，因此可以更灵活地控制页面的渲染流程，避免不必要的页面重绘，提高页面的性能。</li><li>简化复杂性： 虚拟DOM可以将页面的结构和状态抽象成JavaScript对象，使得页面的渲染逻辑更加清晰和易于维护，降低了页面开发的复杂度。</li><li>支持Diff算法： 虚拟DOM可以通过Diff算法找出需要更新的部分，从而避免对整个页面进行重新渲染，减少了不必要的DOM操作，提高了页面的渲染效率。</li></ol><h3 id="虚拟dom-更新流程" tabindex="-1">虚拟dom 更新流程 <a class="header-anchor" href="#虚拟dom-更新流程" aria-label="Permalink to &quot;虚拟dom 更新流程&quot;">​</a></h3><ol><li>数据更新触发： 当Vue组件的数据发生变化时，Vue会重新计算虚拟DOM。</li><li>虚拟DOM生成： 根据最新的数据，Vue会重新生成虚拟DOM树，这个过程是一个纯JavaScript的操作，不会直接操作真实的DOM。</li><li>虚拟DOM比较： Vue会将新生成的虚拟DOM树与之前的虚拟DOM树进行比较，找出两者之间的差异。 <ul><li>Vue 2.0 中虚拟 DOM 的比较是通过 Diff 算法来实现的，其主要过程如下： <ul><li>初始化渲染（首次渲染）： 首次渲染时，会将虚拟 DOM 转换为真实 DOM，并挂载到页面上。</li><li>更新渲染（更新时的渲染）： 当数据发生变化时，Vue 会生成一个新的虚拟 DOM 树，然后通过 Diff 算法将新旧虚拟 DOM 进行比较，找出需要更新的部分，并将这部分更新到真实 DOM 上。</li><li>Diff 算法： Diff 算法是指比较新旧虚拟 DOM 树的算法，其核心思想是通过深度优先搜索的方式逐层对比新旧节点，找出需要更新的节点。Diff 算法会在以下几个方面进行优化： <ul><li>同级比较： Diff 算法会先比较同级节点，如果某个节点发生了变化，则会对比其子节点。</li><li>节点复用： 如果某个节点在新旧虚拟 DOM 中是同一个节点（即具有相同的标签和 key），则会尽可能地复用该节点，而不是重新创建一个节点。</li><li>列表节点的优化： 对于列表节点，Diff 算法会通过节点的 key 属性来判断节点的移动、新增和删除，以减少对真实 DOM 的操作次数。</li></ul></li><li>更新策略： Vue 2.0 中采用的是异步更新策略，即在数据发生变化时，并不会立即更新真实 DOM，而是将变更记录在一个队列中，然后在下一个事件循环中统一更新。这样可以避免频繁地操作真实 DOM，提高性能。</li></ul><blockquote><p>通过以上方式，Vue 2.0 实现了高效的虚拟 DOM 比较和更新机制，保证了页面更新的性能和效率。</p></blockquote></li></ul></li><li>差异更新： Vue会根据比较得到的差异（补丁），将这些差异应用到真实的DOM上，从而实现页面的更新。</li><li>DOM更新： 将差异应用到真实的DOM上后，浏览器会根据更新后的DOM结构重新渲染页面。</li></ol><blockquote><p>这个过程中，虚拟DOM起到了一个中间层的作用，可以帮助Vue高效地进行DOM更新，减少了对真实DOM的直接操作，提高了页面的性能。</p></blockquote><h3 id="如何防止进行不必要的渲染" tabindex="-1">如何防止进行不必要的渲染? <a class="header-anchor" href="#如何防止进行不必要的渲染" aria-label="Permalink to &quot;如何防止进行不必要的渲染?&quot;">​</a></h3><p>在Vue 2.0中，你可以采取以下几种方式来防止虚拟DOM中不必要的重新渲染：</p><ol><li>使用<code>v-if</code>和<code>v-show</code>指令： 使用v-if和v-show指令可以根据条件决定是否渲染DOM元素。v-if会完全销毁和重建元素，而v-show只是控制元素的显示和隐藏，但不会销毁和重建。</li><li>使用<code>computed</code>属性： 将需要频繁计算的结果放在computed属性中，Vue会缓存computed属性的结果，只有在相关响应式依赖发生变化时才会重新计算。</li><li>使用<code>watch</code>属性： 通过watch属性监视数据的变化，在数据变化时执行相应的操作，避免不必要的重新渲染。</li><li>使用<code>keep-alive</code>组件： keep-alive组件可以缓存不活动的组件实例，当组件被切换时，不会销毁组件实例，而是将其缓存起来，以减少不必要的重新渲染。</li><li>使用<code>函数式组件</code>： 函数式组件是无状态的，只接收props作为参数，并返回一个VNode，不会创建组件实例，因此在重新渲染时性能更高。</li></ol><blockquote><p>通过以上方式，可以有效地防止Vue 2.0中虚拟DOM中不必要的重新渲染，提升页面性能和用户体验。</p></blockquote><h3 id="diff-算法" tabindex="-1">diff 算法 <a class="header-anchor" href="#diff-算法" aria-label="Permalink to &quot;diff 算法&quot;">​</a></h3><blockquote><p>Diff算法（差异比对算法）是Vue.js中用于比较虚拟DOM树的一种算法，主要用于识别新旧虚拟DOM树之间的差异，并将差异应用到实际的DOM操作中，从而实现页面的更新。</p></blockquote><p>Vue 2.0中的Diff算法包括以下几个步骤：</p><ol><li>初始化渲染： 首次渲染时，会通过虚拟DOM构建真实DOM，并挂载到页面上。</li><li>创建虚拟DOM： Vue组件中的render函数会返回一个描述组件内容的虚拟DOM树。</li><li>生成新旧虚拟DOM树： 每次组件更新时，都会生成新的虚拟DOM树，与上一次的虚拟DOM树进行比较。</li><li>执行Diff算法： Diff算法会递归地遍历新旧虚拟DOM树，找出两棵树之间的差异。</li><li>比较节点： 对比同层级的节点，判断节点类型是否相同，如果不同则直接替换，如果相同则比较节点的属性和子节点。</li><li>更新节点： 如果节点类型相同但属性不同，则更新节点的属性。如果有子节点，则递归地对子节点进行Diff。</li><li>删除节点： 如果新的虚拟DOM树中不存在的节点，在旧的虚拟DOM树中存在，则直接删除该节点。</li><li>插入节点： 如果在旧的虚拟DOM树中不存在的节点，在新的虚拟DOM树中存在，则直接在相应位置插入该节点。</li><li>批量更新DOM： 在完成Diff比较后，根据差异生成最小更新操作序列，并批量执行实际的DOM更新操作，以减少对实际DOM的操作次数。</li></ol><blockquote><p>通过Diff算法，Vue 2.0能够高效地更新页面，并且只更新发生变化的部分，避免了不必要的DOM操作，提升了页面的性能。</p></blockquote><h3 id="手动触发虚拟dom-更新" tabindex="-1">手动触发虚拟dom 更新 <a class="header-anchor" href="#手动触发虚拟dom-更新" aria-label="Permalink to &quot;手动触发虚拟dom 更新&quot;">​</a></h3><blockquote><p>在Vue.js中，通常不建议手动触发虚拟DOM的更新，因为Vue.js的响应式系统会自动追踪依赖，并在数据变化时更新相关的虚拟DOM。 但是，如果确实有这样的需求，可以通过以下几种方式手动触发虚拟DOM的更新：</p></blockquote><ol><li>$forceUpdate方法： 可以调用组件实例的<code>$forceUpdate</code>方法来强制重新渲染组件，即使没有数据变化。这将会触发组件的重新渲染和虚拟DOM的更新。<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$forceUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div></li><li>$nextTick方法： 可以使用<code>$nextTick</code>方法在DOM更新之后执行一段代码，可以在回调函数中执行需要更新的逻辑。<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$nextTick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 执行更新逻辑</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li><li>手动修改响应式数据： 直接修改响应式数据的值也会触发组件的重新渲染和虚拟DOM的更新。<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newData; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 修改响应式数据</span></span></code></pre></div></li></ol><blockquote><p>需要注意的是，尽量避免频繁地手动触发虚拟DOM的更新，因为Vue.js的响应式系统会自动管理组件的更新，手动触发可能会导致不必要的性能开销。</p></blockquote><h3 id="虚拟dom中的批量更新" tabindex="-1">虚拟dom中的<code>批量更新</code> <a class="header-anchor" href="#虚拟dom中的批量更新" aria-label="Permalink to &quot;虚拟dom中的`批量更新`&quot;">​</a></h3><ul><li>&quot;批量更新&quot;在Vue.js中的作用是将多次数据变更的操作合并成一次更新操作，从而减少不必要的重复渲染，提高性能。</li><li>在Vue.js中，当数据发生变化时，Vue会将变更记录在一个队列中，并在事件循环的下一个tick时，批量处理这些变更。</li><li>这样可以保证在同一事件循环中多次数据变更只触发一次重新渲染。</li><li>具体来说，Vue使用了nextTick机制，将数据变更操作放在nextTick回调中执行。在同一事件循环中，多个数据变更操作会被合并到同一个nextTick回调中，从而实现批量更新。</li><li>这种批量更新的机制可以有效地减少DOM操作次数，提高页面性能，同时还能确保数据变更之后的DOM状态是一致的。</li></ul><h3 id="虚拟dom-局限性" tabindex="-1">虚拟dom 局限性 <a class="header-anchor" href="#虚拟dom-局限性" aria-label="Permalink to &quot;虚拟dom 局限性&quot;">​</a></h3><p>Vue 2.0 虚拟DOM的局限性主要包括：</p><ol><li>性能开销： 虽然虚拟DOM可以减少直接操作真实DOM所带来的性能开销，但是在进行虚拟DOM的比较和更新时，仍然需要消耗一定的计算资源，尤其是在更新频繁的情况下。</li><li>内存占用： 虚拟DOM需要在JavaScript内存中维护一份虚拟DOM树的副本，因此会增加内存占用。</li><li>复杂性增加： 引入虚拟DOM会增加代码的复杂性，尤其是对于初学者来说，需要理解虚拟DOM的概念和工作原理。</li><li>不适合小型应用： 对于一些简单的小型应用，引入虚拟DOM可能会显得繁琐和不必要，增加了开发成本。</li><li>可能出现性能问题： 虽然虚拟DOM可以提高性能，但在某些情况下，比如数据量较大或更新频率较高时，仍可能出现性能问题。</li></ol><blockquote><p>尽管存在这些局限性，但虚拟DOM在大多数情况下仍然是一个非常有效的工具，可以帮助开发者更高效地构建交互式的Web应用。Vue 2.0 通过一些优化措施，如虚拟DOM的异步更新和批量更新等，来减少这些局限性带来的影响。</p></blockquote><h3 id="概念自查" tabindex="-1">概念自查 <a class="header-anchor" href="#概念自查" aria-label="Permalink to &quot;概念自查&quot;">​</a></h3><ol><li>什么是虚拟DOM？它的工作原理是什么？</li><li>虚拟DOM相比于真实DOM有什么优势？</li><li>Vue.js和React中的虚拟DOM实现有何异同？ <ul><li>Vue.js 和 React 中的虚拟DOM 实现有以下异同： <ol><li>相似之处： <ul><li>抽象层级： 两者都采用了虚拟DOM的概念，将整个DOM结构抽象为一个树形结构，以便于对其进行比较和更新。</li><li>性能优化： 虚拟DOM 的引入都是为了提高性能，通过在JavaScript中对虚拟DOM进行操作，减少直接操作真实DOM所带来的性能开销。</li></ul></li><li>差异之处： <ul><li>模板语法： Vue.js 更倾向于采用模板语法，使用 HTML 模板来描述组件的结构，而 React 更倾向于使用 JSX，将组件的结构和逻辑混合在一起。</li><li>更新策略： Vue.js 中采用了响应式数据和依赖追踪的方式，当数据发生变化时，只会更新发生变化的部分，而 React 中则采用了一种叫做“协调”（Reconciliation）的算法来确定哪些部分需要更新。</li><li>批量更新： Vue.js 中的虚拟DOM更新是异步的，会在下一个事件循环中批量执行，而 React 中的虚拟DOM更新是同步的，会立即执行。</li><li>状态管理： Vue.js 提供了 Vuex 来管理应用的状态，而 React 则更加灵活，可以选择使用 Context API、Redux 等状态管理工具。</li></ul></li></ol><blockquote><p>总体来说，Vue.js 和 React 中的虚拟DOM 实现都是为了提高性能和开发效率，但在具体的实现细节和使用方式上存在一些差异。开发者可以根据项目需求和个人偏好选择适合的框架。</p></blockquote></li></ul></li><li>请简要说明虚拟DOM的更新流程。</li><li>如何防止虚拟DOM中不必要的重新渲染？</li><li>什么是Diff算法？它在虚拟DOM中的作用是什么？</li><li>如何手动触发虚拟DOM的更新？</li><li>请解释一下“批量更新”在虚拟DOM中的作用。</li><li>什么是key属性？它在虚拟DOM中的作用是什么？</li><li>虚拟DOM的局限性有哪些？如何解决这些局限性？</li></ol>',43),s=[t];function D(c,M,O,d,p,u){return e(),l("div",null,s)}const r=i(o,[["render",D]]);export{n as __pageData,r as default};
