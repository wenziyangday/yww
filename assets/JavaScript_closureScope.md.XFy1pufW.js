import{_ as l,c as e,o as i,V as a}from"./chunks/framework.j2uNBPO8.js";const b=JSON.parse('{"title":"作用域和闭包","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"JavaScript/closureScope.md","filePath":"JavaScript/closureScope.md"}'),o={name:"JavaScript/closureScope.md"},c=a('<h1 id="作用域和闭包" tabindex="-1">作用域和闭包 <a class="header-anchor" href="#作用域和闭包" aria-label="Permalink to &quot;作用域和闭包&quot;">​</a></h1><blockquote><p>JavaScript 中的一些核心概念</p></blockquote><h3 id="作用域" tabindex="-1">作用域 <a class="header-anchor" href="#作用域" aria-label="Permalink to &quot;作用域&quot;">​</a></h3><blockquote><p>在JavaScript中，作用域（Scope）指的是变量的可访问性和生命周期。<br> JavaScript采用词法作用域（Lexical Scope），也称为静态作用域，这意味着变量的作用域在代码编译阶段就已经确定， 而不是在运行时确定。 作用域规定了在程序中哪些部分可以访问哪些变量，以及变量在何处可以被访问。</p></blockquote><ol><li>全局作用域（Global Scope） <ul><li>全局作用域 是指在代码中<code>任何位置</code>都<code>可以访问</code>的作用域。</li><li>在浏览器环境中，全局作用域指的是window对象。</li><li>在Node.js环境中，全局作用域指的是global对象。</li><li>全局作用域中定义的变量和函数在整个程序中都是可见的。</li></ul></li><li>函数作用域（Function Scope） <ul><li>函数作用域 是指在函数<code>内部定义</code>的变量和函数只能在该函数内部访问，<code>外部无法访问</code>。</li><li>这意味着函数作用域中的变量在函数执行完毕后会被销毁，不会影响到全局作用域。</li></ul></li><li>块级作用域（Block Scope） <ul><li>块级作用域 是指由一对花括号（{}）包裹起来的代码块，在这个代码<code>块中定义</code>的变量只在该代码<code>块内部有效</code>。</li><li>在ES6之前，JavaScript没有块级作用域，变量只有全局作用域和函数作用域。</li><li>ES6引入了let和const关键字，可以用来声明块级作用域变量和常量。</li></ul></li><li>词法作用域（Lexical Scope）-- 静态作用域 <ul><li>词法作用域 是指<code>变量的作用域</code>由代码中变量<code>声明的位置</code>决定的，与函数调用的位置无关。</li><li>在词法作用域中，函数的作用域在函数定义时就已经确定，而不是在函数调用时确定。</li><li>这种作用域规则使得内部函数可以访问外部函数的变量，形成闭包。</li></ul></li></ol><blockquote><p>总的来说，JavaScript的作用域规则决定了变量的可访问性和生命周期，合理使用作用域可以提高代码的可维护性和性能。</p></blockquote><hr><h3 id="作用域链" tabindex="-1">作用域链 <a class="header-anchor" href="#作用域链" aria-label="Permalink to &quot;作用域链&quot;">​</a></h3><ul><li>作用域链（Scope Chain）是指在代码执行期间，JavaScript引擎根据词法作用域（Lexical Scope）确定变量和函数的访问权限 的<code>一种机制</code>。</li><li>作用域链是由一系列的执行上下文（Execution Context）组成的，每个执行上下文都包含了一个变量对象（Variable Object）和指向父级执行上下文的引用。</li></ul><h4 id="作用域规则" tabindex="-1">作用域规则 <a class="header-anchor" href="#作用域规则" aria-label="Permalink to &quot;作用域规则&quot;">​</a></h4><ul><li>作用域规则是指在JavaScript中变量和函数的查找顺序和范围。</li><li>JavaScript采用<code>词法作用域</code>，也称为<code>静态作用域</code>，即在代码编译阶段确定变量的作用域，而不是在运行时确定。</li></ul><h6 id="动态作用域" tabindex="-1">动态作用域 <a class="header-anchor" href="#动态作用域" aria-label="Permalink to &quot;动态作用域&quot;">​</a></h6><blockquote><p>动态作用域是在函数调用时根据调用栈动态确定的，与函数定义的位置无关。</p></blockquote><ul><li>在动态作用域中，变量的作用域取决于函数的调用位置，而不是函数的定义位置。</li><li>这意味着在动态作用域中，内部函数可以访问调用它的函数的变量，而不是定义它的函数的变量。</li><li>动态作用域在函数调用时根据调用栈动态确定当前作用域链。</li></ul><h4 id="嵌套关系" tabindex="-1">嵌套关系 <a class="header-anchor" href="#嵌套关系" aria-label="Permalink to &quot;嵌套关系&quot;">​</a></h4><ul><li>在JavaScript中，函数可以嵌套定义，内部函数可以访问外部函数的变量，但外部函数不能访问内部函数的变量。</li><li>这种嵌套关系形成了作用域链，内部函数的作用域包含了外部函数的作用域。</li></ul><h3 id="闭包" tabindex="-1">闭包 <a class="header-anchor" href="#闭包" aria-label="Permalink to &quot;闭包&quot;">​</a></h3><ul><li>闭包 是指<code>内部函数</code>可以访问<code>外部函数作用域</code>中的变量，即使外部函数执行完毕后，内部函数仍然可以访问外部函数的变量。</li><li>闭包通过作用域链实现，内部函数的作用域包含了外部函数的作用域，因此可以访问外部函数的变量。</li></ul><h4 id="闭包作用" tabindex="-1">闭包作用 <a class="header-anchor" href="#闭包作用" aria-label="Permalink to &quot;闭包作用&quot;">​</a></h4><ol><li>保护数据 <ul><li>闭包可以将变量封装在内部函数中，使得外部无法直接访问，从而保护数据不受外部的影响和篡改。</li></ul></li><li>延长变量的生命周期 <ul><li>在外部函数执行完毕后，闭包仍然可以访问外部函数的局部变量，因此可以延长变量的生命周期，使得在内部函数中仍然可以使用这些变量。</li></ul></li><li>实现私有成员 <ul><li>通过闭包，可以模拟实现类似于面向对象语言中的私有成员，即只有内部函数可以访问的变量和方法，从而提高代码的安全性和可维护性。</li></ul></li><li>实现函数柯里化 <ul><li>闭包可以将函数分步执行，将多个参数的函数转化为接受单一参数的函数，并返回一个新的函数，从而实现函数柯里化，方便参数传递和复用。</li></ul></li><li>模块化开发 <ul><li>通过闭包可以实现模块化开发，将相关的变量和方法封装在一个闭包中，对外暴露需要暴露的接口，从而实现代码的模块化和封装。</li></ul></li></ol>',20),t=[c];function r(d,u,n,h,p,s){return i(),e("div",null,t)}const _=l(o,[["render",r]]);export{b as __pageData,_ as default};
