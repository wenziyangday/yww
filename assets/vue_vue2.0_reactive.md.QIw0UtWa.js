import{_ as t,c as l,m as s,a as i,t as n,V as a,o as h}from"./chunks/framework.j2uNBPO8.js";const v=JSON.parse('{"title":"响应式数据","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"vue/vue2.0/reactive.md","filePath":"vue/vue2.0/reactive.md"}'),p={name:"vue/vue2.0/reactive.md"},r=a(`<h1 id="响应式数据" tabindex="-1">响应式数据 <a class="header-anchor" href="#响应式数据" aria-label="Permalink to &quot;响应式数据&quot;">​</a></h1><h3 id="实现原理" tabindex="-1">实现原理 <a class="header-anchor" href="#实现原理" aria-label="Permalink to &quot;实现原理&quot;">​</a></h3><ul><li>Vue.js 2.0 中的响应式数据绑定是通过 Object.defineProperty() 方法实现的。</li><li>在 Vue.js 中，当数据发生变化时，相关的视图会自动更新，这是通过在数据对象上设置 getter 和 setter 来实现的。</li><li>具体来说，Vue.js 在初始化数据对象时，会遍历数据对象的所有属性，并使用 Object.defineProperty() 方法将它们转换为 getter 和 setter，</li><li>当访问或修改属性值时，会触发相应的 getter 和 setter，从而实现数据的响应式变化。 例如，当我们定义一个 Vue 实例时：</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  data: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    message: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello, Vue.js!&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><blockquote><p>Vue.js 会将 data 对象中的 message 属性转换为 getter 和 setter，使得当我们访问或修改 message 属性时，能够触发视图的更新。 这种响应式数据绑定机制使得 Vue.js 在处理数据变化时能够自动更新相关的视图，极大地简化了前端开发中的数据操作和视图更新过程。</p></blockquote><hr><h3 id="数据双向绑定原理" tabindex="-1">数据双向绑定原理 <a class="header-anchor" href="#数据双向绑定原理" aria-label="Permalink to &quot;数据双向绑定原理&quot;">​</a></h3><p>Vue.js 中的数据双向绑定原理主要基于以下两个概念：</p><ol><li>数据响应式： Vue.js 使用 Object.defineProperty() 方法或 Proxy 对象来实现数据的响应式。这意味着当数据发生变化时，相关的视图会自动更新。</li><li>指令： Vue.js 中的指令是特殊的 HTML 属性，用于将 DOM 元素与数据进行绑定。例如，v-model 指令用于实现表单输入元素与数据的双向绑定。</li></ol><ul><li>当使用 v-model 指令绑定一个表单输入元素时，Vue.js 会在该元素上监听 input 事件，并在事件触发时更新绑定的数据。</li><li>同时，当数据发生变化时，Vue.js 也会更新绑定的表单输入元素的值，从而实现数据的双向绑定。</li></ul><blockquote><p>综上所述，Vue.js 的数据双向绑定原理是通过将数据与 DOM 元素进行绑定，并监听数据和 DOM 元素的变化事件，以实现数据的自动更新和反映，从而实现了数据和视图的同步。</p></blockquote><h3 id="响应式系统" tabindex="-1">响应式系统 <a class="header-anchor" href="#响应式系统" aria-label="Permalink to &quot;响应式系统&quot;">​</a></h3><blockquote><p>Vue.js 的响应式系统是其核心特性之一，它使得数据与视图之间能够实现动态的<code>同步更新</code></p></blockquote><h4 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h4><p>Vue.js 的响应式系统是其核心特性之一，它使得数据与视图之间能够实现动态的同步更新。它的工作原理可以概括为以下几个步骤：</p><ol><li><strong>数据劫持：</strong> 当一个 Vue 实例被创建时，Vue 会遍历数据对象的每一个属性，使用 Object.defineProperty() 方法或 Proxy 对象将这些属性转换为 getter 和 setter。这样一来，当属性被访问或修改时，Vue 就能监听到，并执行相应的更新操作。</li><li><strong>依赖追踪：</strong> 在数据劫持的过程中，Vue 会建立一个依赖追踪系统。当一个属性被访问时，Vue 会将当前的 Watcher 对象（观察者）与该属性建立关联，并将 Watcher 对象添加到一个全局的依赖列表中。这样一来，每个属性都知道自己有哪些 Watcher 对象依赖于它。</li><li><strong>响应式更新：</strong> 当一个属性被修改时，Vue 会通过 setter 触发相应的更新操作。Vue 会遍历依赖列表，通知每个 Watcher 对象进行更新。Watchers 会重新计算虚拟 DOM，并将新的结果与旧的结果进行比较，从而确定需要更新的部分。</li><li><strong>DOM 更新：</strong> 一旦确定需要更新的部分，Vue 会将新的虚拟 DOM 渲染为实际的 DOM，并将其插入到页面中，完成视图的更新。</li></ol><blockquote><p>这样一来，当数据发生变化时，Vue 的响应式系统会自动将变化反映到相应的视图上，从而实现了数据与视图的动态同步更新。</p></blockquote><h3 id="监听变化" tabindex="-1">监听变化 <a class="header-anchor" href="#监听变化" aria-label="Permalink to &quot;监听变化&quot;">​</a></h3><h4 id="数据变化" tabindex="-1">数据变化 <a class="header-anchor" href="#数据变化" aria-label="Permalink to &quot;数据变化&quot;">​</a></h4><p>在 Vue.js 2.0 中，可以通过以下几种方式监听数据的变化：</p>`,20),o=s("strong",null,"Watcher：",-1),k=s("code",null,"watch",-1),c=a("<li><strong>计算属性（Computed）：</strong> 计算属性是根据其他属性计算得到的属性，在依赖的属性发生变化时会重新计算。你可以在组件的选项中使用 <code>computed</code> 属性来定义计算属性。</li><li><strong>侦听器（Watch）：</strong> 侦听器是一种更通用的方式来监听数据的变化，它可以监听任何数据的变化，并在数据发生变化时执行相应的回调函数。你可以在组件的选项中使用 <code>watch</code> 属性来定义侦听器。</li><li><strong>$watch API：</strong> 除了在组件的选项中定义 Watcher 和侦听器外，你还可以使用 Vue 实例的 <code>$watch</code> 方法来动态地创建 Watcher。这种方式适用于在组件之外监听数据的变化。</li>",3),d=a(`<blockquote><p>这些方式可以让你在 Vue.js 中方便地监听数据的变化，并在数据发生变化时执行相应的逻辑。</p></blockquote><h4 id="数组变化" tabindex="-1">数组变化 <a class="header-anchor" href="#数组变化" aria-label="Permalink to &quot;数组变化&quot;">​</a></h4><p>在 Vue.js 2.0 中，要监听数组的变化，可以使用以下几种方式：</p><ol><li><p><strong>使用 Watcher 监听数组：</strong> 在组件的选项中使用 <code>watch</code> 属性，监听数组的变化。在 Watcher 中可以使用深度监听属性 <code>deep: true</code> 来监听数组内部元素的变化。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  myArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newVal, oldVal) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 数组发生变化时执行的逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    deep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 深度监听数组内部元素的变化</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>使用计算属性（Computed）：</strong> 在组件的选项中使用 <code>computed</code> 属性，定义一个计算属性，该计算属性依赖于数组，并在计算属性中处理数组的变化。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">computed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  processedArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理数组的逻辑</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.myArray.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* 处理每个元素的逻辑 */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>使用 Vue.set 或 this.$set 方法：</strong> 使用 <code>Vue.set</code> 或 <code>this.$set</code> 方法向数组中添加新元素，这样可以确保新增的元素也被 Vue.js 监听到，并触发相应的更新。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.myArray, index, newValue); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue.set 方法</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.myArray, index, newValue); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// this.$set 方法</span></span></code></pre></div></li><li><p><strong>监听数组变异方法：</strong> Vue.js 通过拦截数组的变异方法（如 push、pop、shift、unshift、splice、sort 和 reverse）来监听数组的变化。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.myArray.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newValue); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 触发数组变异方法 push，Vue.js 监听到并更新视图</span></span></code></pre></div></li></ol><blockquote><p>这些方法可以让你在 Vue.js 中方便地监听数组的变化，并在数组发生变化时执行相应的逻辑。</p></blockquote><hr><h3 id="watcher" tabindex="-1">watcher <a class="header-anchor" href="#watcher" aria-label="Permalink to &quot;watcher&quot;">​</a></h3><blockquote><p>在 Vue.js 中，侦听器（watcher）是一个用于观察 Vue 实例数据变化的重要机制。 侦听器会在监视的数据发生变化时执行指定的回调函数，从而实现对数据变化的响应。</p></blockquote><p>侦听器的作用主要有以下几点：</p><ol><li><strong>监视数据变化：</strong> 侦听器会监视指定的数据，当该数据发生变化时，侦听器会立即执行相应的回调函数。</li><li><strong>执行副作用逻辑：</strong> 侦听器的回调函数可以执行任意副作用逻辑，例如更新视图、发送网络请求、处理数据等，从而实现对数据变化的响应。</li><li><strong>处理异步任务：</strong> 侦听器的回调函数也可以处理异步任务，例如等待数据加载完成后再更新视图，或者等待用户输入后再进行下一步操作。</li><li><strong>跟踪数据变化：</strong> 侦听器会跟踪数据的变化情况，包括数据的新值和旧值，从而可以根据具体情况执行不同的逻辑。</li></ol><blockquote><p>总之，侦听器是 Vue.js 中实现数据响应式的重要机制之一，它可以帮助我们监视数据的变化，并在数据变化时执行相应的逻辑，从而实现对数据的有效管理和控制。</p></blockquote><hr><h3 id="概念自查" tabindex="-1">概念自查 <a class="header-anchor" href="#概念自查" aria-label="Permalink to &quot;概念自查&quot;">​</a></h3><ol><li>Vue.js 中的响应式数据是如何实现的？</li><li>请解释一下 Vue.js 的数据双向绑定原理。</li><li>什么是 Vue.js 的响应式系统？它是如何工作的？</li><li>Vue.js 中的数据劫持是如何实现的？</li><li>介绍一下 Vue.js 的数据响应式原理和数据更新机制。</li><li>你知道 Vue.js 中的 Object.defineProperty() 方法吗？它在响应式数据中的作用是什么？</li><li>Vue.js 的响应式数据和 React 的响应式数据有什么区别？</li><li>Vue.js 2.0 中如何监听数据的变化？</li><li>在 Vue.js 中，如何监听数组的变化？</li><li>请解释 Vue.js 的侦听器（watcher）是什么，以及它的作用是什么？</li></ol>`,14);function u(e,g,E,y,V,b){return h(),l("div",null,[r,s("ol",null,[s("li",null,[o,i(" Watcher 是 Vue.js 内部使用的一个类，它可以观察数据的变化，并在数据发生变化时执行相应的回调函数。你可以在组件的选项中使用 "),k,i(" 属性或者在模板中使用 "),s("code",null,n(e.expression),1),i(" 来创建 Watcher。")]),c]),d])}const j=t(p,[["render",u]]);export{v as __pageData,j as default};
