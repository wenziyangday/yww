import{_ as e,c as i,o as a,V as t}from"./chunks/framework.9nulytGH.js";const k=JSON.parse('{"title":"依赖预构建","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"performances/vitePreBuild.md","filePath":"performances/vitePreBuild.md"}'),o={name:"performances/vitePreBuild.md"},l=t(`<h1 id="依赖预构建" tabindex="-1">依赖预构建 <a class="header-anchor" href="#依赖预构建" aria-label="Permalink to &quot;依赖预构建&quot;">​</a></h1><blockquote><p>当你首次启动 vite 时，Vite 在本地加载你的站点之前预构建了项目依赖。 默认情况下，它是自动且透明地完成的。</p></blockquote><hr><h3 id="原因" tabindex="-1">原因 <a class="header-anchor" href="#原因" aria-label="Permalink to &quot;原因&quot;">​</a></h3><p>这就是 Vite 执行时所做的“依赖预构建”。这个过程有两个目的:</p><ol><li><p>CommonJS 和 UMD 兼容性:</p><ul><li>在开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将以 CommonJS 或 UMD 形式提供的依赖项转换为 ES 模块。</li><li>在转换 CommonJS 依赖项时，Vite 会进行智能导入分析，这样即使模块的导出是动态分配的（例如 React），具名导入（named imports）也能正常工作：<div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 符合预期</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React, { useState } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span></span></code></pre></div></li></ul></li><li><p>性能：</p><ul><li>为了提高后续页面的加载性能，Vite将那些具有许多内部模块的 ESM 依赖项转换为单个模块。</li></ul><p>有些包将它们的 ES 模块构建为许多单独的文件，彼此导入。例如，lodash-es 有超过 600 个内置模块！当我们执行 import { debounce } from &#39;lodash-es&#39; 时，浏览器同时发出 600 多个 HTTP 请求！ 即使服务器能够轻松处理它们，但大量请求会导致浏览器端的网络拥塞，使页面加载变得明显缓慢。</p><p>通过将 lodash-es 预构建成单个模块，现在我们只需要一个HTTP请求！</p></li></ol><blockquote><p>注意: <br> 依赖预构建仅适用于开发模式，并使用 esbuild 将依赖项转换为 ES 模块。在生产构建中，将使用 @rollup/plugin-commonjs。</p></blockquote><hr><h3 id="自动依赖搜寻" tabindex="-1">自动依赖搜寻 <a class="header-anchor" href="#自动依赖搜寻" aria-label="Permalink to &quot;自动依赖搜寻&quot;">​</a></h3><p>如果没有找到现有的缓存，Vite 会扫描您的源代码，并自动寻找引入的依赖项（即 &quot;bare import&quot;，表示期望从 node_modules 中解析），并将这些依赖项作为预构建的入口点。预打包使用 esbuild 执行，因此通常速度非常快。</p><p>在服务器已经启动后，如果遇到尚未在缓存中的新依赖项导入，则 Vite 将重新运行依赖项构建过程，并在需要时重新加载页面。</p><hr><h3 id="自定义行为" tabindex="-1">自定义行为 <a class="header-anchor" href="#自定义行为" aria-label="Permalink to &quot;自定义行为&quot;">​</a></h3><p>有时候默认的依赖启发式算法（discovery heuristics）可能并不总是理想的。如果您想要明确地包含或排除依赖项，可以使用 <code>optimizeDeps</code> 配置项 来进行设置。</p><p>optimizeDeps.include 或 optimizeDeps.exclude 的一个典型使用场景，是当 Vite 在源码中无法直接发现 import 的时候。 例如，import 可能是插件转换的结果。 这意味着 Vite <code>无法在初始扫描时发现 import</code> —— 只能在文件被浏览器请求并转换后才能发现。这将导致服务器在启动后立即重新打包。</p><p>你可以通过 optimizeDeps.esbuildOptions 选项 进一步自定义 esbuild。例如，添加一个 esbuild 插件来处理依赖项中的特殊文件，或者更改 build target。</p><hr><h3 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-label="Permalink to &quot;缓存&quot;">​</a></h3><h5 id="文件系统缓存" tabindex="-1">文件系统缓存 <a class="header-anchor" href="#文件系统缓存" aria-label="Permalink to &quot;文件系统缓存&quot;">​</a></h5><p>Vite 将预构建的依赖项<code>缓存</code>到 node_modules/.vite 中。它会基于以下几个来源来决定是否需要重新运行预构建步骤：</p><ul><li>包管理器的锁文件内容，例如 package-lock.json，yarn.lock，pnpm-lock.yaml，或者 bun.lockb；</li><li>补丁文件夹的修改时间；</li><li>vite.config.js 中的相关字段；</li><li>NODE_ENV 的值。</li></ul><p>只有在上述其中一项发生更改时，才需要重新运行预构建。</p><p>如果出于某些原因你想要强制 Vite 重新构建依赖项，你可以在启动开发服务器时指定 --force 选项，或手动删除 node_modules/.vite 缓存目录。</p><h5 id="浏览器缓存" tabindex="-1">浏览器缓存 <a class="header-anchor" href="#浏览器缓存" aria-label="Permalink to &quot;浏览器缓存&quot;">​</a></h5><p>已预构建的依赖请求使用 HTTP 头 max-age=31536000, immutable 进行<code>强缓存</code>，以提高开发期间页面重新加载的性能。 一旦被缓存，这些请求将<code>永远不会</code>再次访问开发服务器。 如果安装了不同版本的依赖项（这反映在包管理器的 lockfile 中），则会通过附加版本查询自动失效。 如果你想通过本地编辑来调试依赖项，您可以：</p><ol><li>通过浏览器开发工具的 Network 选项卡暂时禁用缓存；</li><li>重启 Vite 开发服务器指定 --force 选项，来重新构建依赖项;</li><li>重新载入页面。</li></ol>`,26),s=[l];function r(p,n,d,c,h,u){return a(),i("div",null,s)}const b=e(o,[["render",r]]);export{k as __pageData,b as default};
